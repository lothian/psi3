%
% PSI Programmer's Manual
%
% PSI Makefiles Section
%
% Daniel Crawford, 31 January, 1996
%
The {\tt make} utility is designed to help maintain the many components of
a large program, such as PSI.  This section will describe the construction
and usefulness of Makefiles in PSI, both in developmental code and in
production-level modules.  We will be concerned only with the GNU Project's
{\tt make} facility, and not older, less flexible versions.

\subsection{Makefile Structure}
The primary purpose of the {\tt make} program is to assist compilation and
recompilation of a multi-file program, such that only the portions of the
program that need to be are recompiled.  For example, if a header file is
changed, then each source file which {\tt \#include}s that file must be
recompiled.  {\tt make} provides an easy mechanism by which such {\em
dependencies} may be tracked.

Makefiles consist of {\em rules} which describe how to carry out commands.
For example, a rule might explain how to compile a single source file, or
how to link all the object files into the executable, or perhaps how to
clean up all the object files.  A rule has the following form
\begin{verbatim}
target: dependencies
        command
        command
        ...
\end{verbatim}
The {\em target} is the name of the rule, e.g.~the name of the program to
be compiled; the first rule given in the Makefile is the default.  The {\em
dependencies} are the names of files (often names of other targets, as
well) on which the construction of the target depends.  A particular target
does not necessarily have to have dependencies.  The {\em commands} are the
actual commands to be executed once all the dependencies are complete.
Note that a \verb <TAB> \ must be used to indent commands under the target
name; if you use spaces or don't indent you'll get a misleading error
message.  Makefiles may also contain variable definitions to make the file
perhaps simpler.  For a complete explanation of GNU {\tt make} syntax, and
a rather nice introduction to Makefiles, see the GNU Make manual or info
page.

\subsection{Developmental Makefiles}
When dealing with developmental code, a simple Makefile is preferred, as it
allows the programmer to quickly redefine optimization parameters, change
dependencies, or add or remove source files from the compilation.  The
following is a simple, flexible Makefile for a PSI developmental code,
named {\tt mycode}, which contains C source:
\begin{verbatim}
include ../MakeVars

CODE = mycode
ARCH = $(shell /usr/local/psi/bin/host.sh)

vpath %.a /usr/local/psi/$(ARCH)/lib:$(ROOT)/lib

INCLUDES = -I./ -I$(ROOT)/include -I/usr/local/psi/include

CFLAGS = -O2 -m486

CLIBS = -lmalloc -lread34 -lfile30 -lqt -lciomr -lipv1 -lm -lbsd

CSRC = \
mycode.c \
gprgid.c \
a_function.c \
b_function.c \

BINOBJ = $(CSRC:%.c=%.o)

$(CODE): $(BINOBJ) $(CLIBS)
	$(CC) $^ -o $(CODE)

%.o: %.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $<

clean:
	/bin/rm -f $(CODE) *.o core

# DO NOT DELETE THIS LINE -- make depend depends on it.
mycode.o: /usr/local/psi/include/libciomr.h 
mycode.o: /usr/local/psi/include/libipv1/ip_lib.h
mycode.o: $(ROOT)/include/qt.h 
mycode.o: $(ROOT)/include/read34.h 
mycode.o: $(ROOT)/include/file30.h
a_function.o: a_function.c globals.h $(ROOT)/include/qt.h
a_function.o: /usr/local/psi/include/libciomr.h 
a_function.o: /usr/local/psi/include/libipv1/ip_lib.h
\end{verbatim}
This Makefile contains a number of variable definitions (e.g.~{\tt CFLAGS},
{\tt BINOBJ}, and {\tt ARCH}), and a series of rules (e.g.~{\tt \$(CODE)},
{\tt \%.o}, and {\tt clean}).  

Most of the variable definitions are straightforward assignments, such as
{\tt CFLAGS}, but a few are more unusual.  The {\tt ARCH} variable is a
dynamic assignment, which varies with the architecture on which the
compilation occurs.  The variable is assigned to whatever output is
returned by the command executed by the {\tt shell} command.  In this case,
the {\tt shell} command executes the {\tt host.sh} program, which returns a
string naming the computer's architecture, e.g.~{\tt power2-ibm-aix4.1}.  A
second unusual assignment is that of the {\tt BINOBJ} variable, which is
assigned using a pattern substitution command.  This command assigns {\tt
BINOBJ} to the list of files given under the {\tt CSRC} variable, with the
{\tt .c} pattern replaced by a {\tt .o}.  The machine-specific {\tt CC} and
{\tt ROOT} variables are assigned in the MakeVars file included at the
beginning of this example.  For example, on a Linux personal computer, one
might want {\tt CC = gcc}, which on the CCQC IBM RS/6000 workstations, one
would want {\tt CC = xlc}.  Finally, note the {\tt CLIBS} variable, which
takes arguments such as -lfile30.  Such strings are automatically expanded
to a form like libfile30.a, which is the true name of the library.  Note
that when a variable is assigned, no \$ is used, but when the variable is
referred to later, the \$ must be given.

The default rule in this Makefile has the target, {\tt \$(CODE)}.  This
rule has two dependencies, {\tt \$(BINOBJ)} and {\tt \$(CLIBS)}.  Before
the command under the rule can be executed, these dependencies must be
satisfied, in the order given.  The {\tt \$(BINOBJ)} dependency simply
means that all the object files must be created first.  The rule for this
is given as the target, {\tt \%.o}.  This rule has only one dependency, and
that is the source code file itself.  Once all the object code has been
created, the next dependency is checked, namely {\tt \$(CLIBS)}.  If this
dependency is not already satisfied, then the programmer is in trouble,
since no rules are provided which explain how to construct {\tt \$(CLIBS)}
is they do not already exist.  {\tt make} searches for libraries given by
{\tt \$(CLIBS)} in a number of places: first, it checks the directories
given by the {\tt vpath} specifier, then a series of default directories,
including {\tt /lib} and {\tt /usr/lib}.  Once the dependencies are
satisfied, the command portion of the rule is executed.  In this case a
linkage command is used.  \verb $^ \ is an example of an automatic
variable, that is a variable which is automatically defined by {\tt make}.
\verb $^ \ is defined to be the list of dependencies of this rule, in order.
Hence, {\tt \$(BINOBJ)} and {\tt \$(CLIBS)} are inserted into the command.
Other automatic variables include \verb $< \ which is the first dependency of
the rule, and \verb $@ \ which is the name of the target.

Note that there are several other rules at the bottom of the Makefile, all
of which have object file names are targets, and which contain only
dependencies and no rules.  These are additional dependencies for the
object files of the program.  These are included so that certain header
file dependencies are accounted for by {\tt make}.  Is is possible (even
recommended for especially large programs) to generate these dependencies
automatically.  See the GNU {\tt make} manual for more information.

\subsection{PSI Makefiles}
The Makefiles contained in the PSI package are quite different from the one
described above for developmental code.  Due to the complexity of PSI and
the need for portability to other platforms, Makefiles are generated
automatically from simple input, called {\tt Makefile.in}, by a script
called {\tt configure}.  This script is designed to examine system-specific
characterisctics, such as library locations, special compiler options, the
existence of certain header files or functions, or Fortran-C cross-linkage
conventions, among others.  With the information it obtains, it constructs
the large number of Makefiles needed for compilation of PSI's libraries,
utilities, and modules.

As an example, consider the {\tt Makefile.in} file associated with {\tt
cscf}:
\begin{verbatim}
srcdir = @srcdir@
VPATH = @srcdir@

include ../MakeVars

CDEF += -DTIME=0 -DNO_TEMPLATES

LD = $(CC)
LDFLAGS = $(CFLAGS)
LDLIBS = $(CLIBS)

PSILIBS = libciomr.a libipv1.a

TRUESRC = cscf.c cleanup.c diis.c dmat.c dmat_2.c ecalc.c  \
          errchk.c findit.c formg2.c formgc.c formgo.c  \
          form_vec.c gprgid.c init_scf.c make_47.c  \
          packit_c.c packit_o.c rdone.c rdtwo.c rotate_vector.c  \
          scf_input.c scf_iter.c scf_iter_2.c schmit.c sdot.c  \
          shalf.c check_rot.c phases.c  \

BINOBJ = $(TRUESRC:%.c=%.o)
ALLOC =

include ../MakeRules

ifneq ($(DODEPEND),no)
$(BINOBJ:%.o=%.d): $(DEPENDINCLUDE)
include $(BINOBJ:%.o=%.d)
endif

install_man:: cscf.1
        $(MKDIRS) $(mandir)/man1
        cat $(top_srcdir)/lib/macro.psi $< | sed "s OS_NAME_HERE UNIX " > \
            $(mandir)/man1/cscf.1
\end{verbatim}

The \verb @string@ directives tell the {\tt configure} script where to
insert certain variables is has determined from the system.   This Makefile
input also includes two external Makefiles, {\tt MakeVars} and {\tt
MakeRules}, both of which are in the parent directory.  These files contain
(not surprisingly) numerous necessary variables (e.g.~the local C compiler
name) and rules (e.g.~how to generate the module itself) for compilation
and installation of {\tt cscf}.  Similar files exist for the PSI libraries
as well.  We recommend that programmer's spend some time studying the PSI
Makefile structure.




